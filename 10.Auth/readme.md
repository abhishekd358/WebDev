# 1) Stateful vs Serverless
<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

1. **Definition of State in Authentication**  
   - **State** = data or information.
   - **Stateful** = server changes state (stores/removes data) when user logs in/out.
   - **Stateless** = server does **not** change any state; only provides a token (e.g., JWT).

2. **Gym Analogy**  
   - **Stateless Gym**: Member gets an ID card with expiry date. No internal record is kept. Canâ€™t revoke access before expiry.
   - **Stateful Gym**: Member gets an ID, but gym keeps a register. Can revoke membership if member misbehaves.

3. **Drawbacks of Stateless Auth**  
   - No control over active sessions.
   - Cannot log out users before token expiry.
   - Cannot block malicious users immediately.
   - Stolen tokens remain valid until expiry.

4. **Drawbacks of Stateful Auth**  
   - More server load (storing sessions).
   - Slightly slower (needs to check session DB).

5. **JWT (JSON Web Token) Discussion**  
   - JWT is **stateless by design**.
   - Often misused for client-server auth; better suited for **server-to-server** auth.
   - Using refresh tokens makes it **stateful/hybrid**.
   

6. **Recommendation**  
   - Use **stateful auth** (session-based) for control and security.
   - Use **stateless** only if you trust all users and scalability is critical.



### **Key Takeaways:**
- **Stateful**: Server stores session data â†’ more control, can revoke access.
- **Stateless**: No server storage â†’ less control, but more scalable.
- **JWT**: Often misused; refresh tokens make it stateful anyway.
- **Hybrid approach**: Common in practice (JWT + refresh token).

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 2) Encryption & Hashing

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>


#### Terminology in Encryption/Decryption

| Term               | Description                                                               |
| ------------------ | ------------------------------------------------------------------------- |
| **Plaintext**      | The original readable message or data.                                    |
| **Ciphertext**     | The encrypted, unreadable version of the plaintext.                       |
| **Encryption**     | The process of converting plaintext into ciphertext using a key.          |
| **Decryption**     | The process of converting ciphertext back to plaintext using a key.       |
| **Key**            | A secret value used in encryption and decryption.                         |
| **Symmetric Key**  | The same key is used for both encryption and decryption.                  |
| **Asymmetric Key** | A key pair: public key (for encryption) and private key (for decryption). |


### 2. **Hashing (Irreversible)**

Hashing is the process of converting data into a fixed-size bits, which typically represents a digest of that data. It is **one-way**, meaning it cannot be reversed.

#### Common Algorithms:

- SHA-256 (Secure Hash Algorithm)
- MD5 (Message Digest Algorithm) (Obsolete)
- SHA-1 (Obsolete)

#### âœï¸ Terminology in Hashing

| Term              | Description                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| **Message**       | The original input data (e.g., a password, file, or string).           |
| **Hash / Digest** | The fixed-length output generated by the hashing algorithm.            |
| **Hash Function** | The algorithm that maps data of arbitrary size to a fixed-size output. |
| **Collision**     | When two different inputs produce the same hash (undesirable).         |
| **Salt**          | Random data added to input to prevent hash-based attacks.              |

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">

# 3) createHash() in Node.js (Crypto)

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

</br>

**âœ” What is createHash()?**
- `createHash()` is a method from Node.js crypto module
- Used to generate HASH of data
- Hash = one-way encrypted value (cannot be reversed)


**âœ” Import crypto module**
- `createHash()` -> Creates hash object 
- `update()` -> Adds data to hash 
- `digest()` -> Final output 

```js
const crypto = require("crypto");
```

```js
crypto.createHash(algorithm)
```

**âœ” Basic Example**

```js
const crypto = require("crypto");

const hash = crypto
  .createHash("sha256")
  .update("password123")
  .digest("hex");

console.log(hash);
```


**âœ” When to Use createHash()?**
- File checksum
- Tokens
- API signature
- Non-password hashing


**âœ” Interview Line **

"createHash() is used to generate a one-way cryptographic hash of data using algorithms like SHA-256."


</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">



# 4) How Hashing is Used in Git 

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

## 1. Git's Hash Mechanism
- **Algorithm**: Git uses **SHA-1** for hashing (historically)
- **Purpose**: Identifies commits, files, and objects uniquely
- **Output Format**: 40-character hexadecimal string

## 2. Git Object Hashing Process

### What Git Actually Hashes:
Git doesn't hash raw file content directly. Instead, it creates a **Git object** by prepending metadata:

```
Format: "blob <content_length>\0<file_content>"
```

Example for a file containing "hello world":
```javascript
// Git creates this structure:
const gitObject = "blob 11\0hello world";
// Then hashes this entire string with SHA-1
```

### Node.js Code to Recreate Git's Hash:
```javascript
import { readFile } from 'fs/promises';
import crypto from 'crypto';

async function calculateGitHash(filename) {
    // Read file content
    const fileData = await readFile(filename);
    
    // Create Git object format
    const contentLength = fileData.length;
    const gitObject = `blob ${contentLength}\0${fileData}`;
    
    // Calculate SHA-1 hash
    const hash = crypto.createHash('sha1');
    hash.update(gitObject);
    const gitHash = hash.digest('hex');
    
    return gitHash;
}
```

## 3. Git's Storage Structure

### How Git Stores Hashed Objects:
1. **First 2 characters** â†’ Folder name
2. **Remaining 38 characters** â†’ File name inside folder

Example: Hash `5e1c309e...`
- Folder: `.git/objects/5e/`
- File: `1c309e...` (compressed content)

### Git Object Types:
1. **Blob**: File content
2. **Tree**: Directory structure
3. **Commit**: Commit metadata
4. **Tag**: Tag references


### Key Takeaways:
1. Git uses **SHA-1** for object identification
2. Hashes are calculated on **structured objects**, not raw files
3. **Avalanche effect** ensures even minor changes produce different hashes

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 5) Signing Cookies in Node.js

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

### Why Sign Cookies?
- To prevent users from modifying sensitive data in cookies (such as expiration time, user information, etc.)
- Even if cookies are Base64 encoded, users can still decode and modify the content
- Signing allows verification of whether cookie data has been altered

## Implementation Steps for Signing

### 1. Create a Signing Function
```javascript
// Import crypto module
import crypto from 'crypto';

// Define secret key (should use environment variables in real projects)
const SECRET_KEY = 'pro-coder-storage-app';

// Create signature
const signature = crypto
  .createHash('sha256')  // Use SHA-256 algorithm
  .update(payload)       // Add cookie data
  .update(SECRET_KEY)    // Add secret key
  .digest('base64url');  // Output in base64url format
```

### 2. Send Signed Cookies
- Convert raw data to Base64 format
- Generate signature for the data
- Connect data and signature using a separator (like a dot `.`)
- Send format: `base64data.signature`

### 3. Verify Signatures
```javascript
// Receive cookie and split it
const [payloadBase64, oldSignature] = token.split('.');

// Recalculate signature
const newSignature = crypto
  .createHash('sha256')
  .update(payload)      // Use received data
  .update(SECRET_KEY)   // Use the same secret key
  .digest('base64url');

// Compare signatures
if (newSignature !== oldSignature) {
  // Signature invalid, cookie tampered with
  res.clearCookie('token');
  return res.status(401).send('Not logged in');
}
```


###  Signature Algorithm Choice
- Use SHA-256 hash algorithm
- Output format uses base64url (URL-compatible, no padding characters)


## Connection to JSON Web Tokens (JWT)
- JWT uses the same fundamental principle
- JWT has three parts separated by two dots: `header.payload.signature`
- Understanding cookie signing helps understand JWT principles
- jwt signature as follow:

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret_key
)
```

#
</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">



# 6) Cookie Parser & Signed Cookies (Node.js / Express)

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

**âœ” What is Cookie Parser?**
- Express middleware for handling cookies
- Automatically parses cookies from request headers
- Makes cookies available as JS objects

**âœ” Problem Without Cookie Parser**
- Manual parsing of Cookie header
- String splitting & decoding
- No built-in signing / verification
- Error-prone & messy

**âœ” Installation**
`npm install cookie-parser`

**âœ” Basic Setup**
`app.use(cookieParser())`
- Parsed cookies â†’ req.cookies

**âœ” 1ï¸âƒ£ Setting Normal Cookie**
`res.cookie("username", "john", { httpOnly: true })`

**âœ” Reading Normal Cookie**
`req.cookies.username`

**âœ” 2ï¸âƒ£ What is Signed Cookie?**
- Cookie with tamper-detection
- Uses secret key + hashing
- NOT encryption (data is readable)

**âœ” Setup for Signed Cookies**
app.use(cookieParser("SECRET_KEY"))

**âœ” Sending Signed Cookie**
res.cookie("token", "data", { signed: true })

âœ” Reading Signed Cookie
req.signedCookies.token
- Valid â†’ value available
- Tampered â†’ false / undefined

**âœ” Behind the Scenes**
- Cookie stored as: `s:value.signature`
- Server recalculates signature
- If mismatch â†’ cookie rejected

**âœ” Security Benefit**
- Detects cookie modification
- Prevents privilege escalation
- Protects userId, roles, session data

**âœ” Important Rules âš ï¸**
- Signed â‰  Encrypted
- User can SEE data
- User cannot MODIFY data silently

**âœ” Where to Store Secret?**
- Environment variables
`process.env.COOKIE_SECRET`

**âœ” When to Use Signed Cookies?**
- User sessions
- Auth tokens
- Role / permission data

**âœ” Complete Implemented example**

```js
const express = require('express');
const cookieParser = require('cookie-parser');
const app = express();
app.use(cookieParser('test-secret'));

// Set a signed cookie
app.get('/set', (req, res) => {
  res.cookie('myCookie', 'secretData', { signed: true });
  res.send('Cookie set! Try visiting /get');
});

// Get the cookie
app.get('/get', (req, res) => {
  const normal = req.cookies.myCookie;
  const signed = req.signedCookies.myCookie;
  
  res.send(`
    Normal cookie: ${normal}<br>
    Signed cookie: ${signed}<br>
    Try modifying the cookie in browser and refresh!
  `);
});

app.listen(3000);
```



**âœ” Interview Line**

"cookie-parser simplifies cookie handling in Express and signed cookies add tamper detection using a secret key."

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">




# 7) What are Rainbow Tables?


<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>


**âœ” What are Rainbow Tables?**
- Precomputed tables of password â†’ hash mappings
- Used to crack hashed passwords quickly

âœ” Simple Definition
Rainbow Table â†’ already stored hashes used to guess original passwords

âœ” Protection Against Rainbow Tables ğŸ”
1) Salting (MOST IMPORTANT)
   salt + password â†’ hash
   - Same password â‰  same hash

2) Slow Hashing Algorithms
   - bcrypt
   - pbkdf2
   - scrypt
   - argon2

âœ” NOT Safe for Passwords âŒ
- md5
- sha1
- sha256 (without salt)


</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 8) Side Effect Import i ES6

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>


âœ” What is a KDF?
- Cryptographic algorithm to derive strong keys from passwords
- Makes weak passwords secure
- Designed to be slow & expensive for attackers


âœ” How KDF Works
Password + Salt
â†’ Hash
â†’ Hash again
â†’ Repeat (100,000+ times)
â†’ Final secure hash

âœ” 3 Magic Ingredients ğŸ”¥
1) Salt
   - Random per user
   - Same password â‰  same hash
   - Stops rainbow tables

2) Iterations
   - Number of hash rounds
   - Slows brute-force attacks
   - Recommended: 100kâ€“300k+

3) Key Length
   - Output size
   - Recommended: 32 bytes

âœ” PBKDF2 (Node.js Built-in KDF)
- Available in crypto module
- Uses HMAC internally
- Slow by design (good)

Example:
`crypto.pbkdf2(password, salt, iterations, keyLen, algo)`

âœ” Password Storage Format
- Store hash + salt together
- Example: hash.salt (base64url)

âœ” Password Verification Flow
1) Split stored hash & salt
2) Recalculate hash with entered password
3) Compare hashes
4) Match â†’ login success

âœ” Comparison (IMPORTANT)
- sha256 â†’ fast, unsafe
- HMAC â†’ better, still fast
- PBKDF2 â†’ slow, secure
- bcrypt â†’ slower, easier
- Argon2 â†’ most secure (modern)


âœ” Interview Line 
"A Key Derivation Function securely hashes passwords using salt and multiple iterations to resist brute-force and rainbow table attacks."

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">