# 1) Stateful vs Serverless
<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

1. **Definition of State in Authentication**  
   - **State** = data or information.
   - **Stateful** = server changes state (stores/removes data) when user logs in/out.
   - **Stateless** = server does **not** change any state; only provides a token (e.g., JWT).

2. **Gym Analogy**  
   - **Stateless Gym**: Member gets an ID card with expiry date. No internal record is kept. Canâ€™t revoke access before expiry.
   - **Stateful Gym**: Member gets an ID, but gym keeps a register. Can revoke membership if member misbehaves.

3. **Drawbacks of Stateless Auth**  
   - No control over active sessions.
   - Cannot log out users before token expiry.
   - Cannot block malicious users immediately.
   - Stolen tokens remain valid until expiry.

4. **Drawbacks of Stateful Auth**  
   - More server load (storing sessions).
   - Slightly slower (needs to check session DB).

5. **JWT (JSON Web Token) Discussion**  
   - JWT is **stateless by design**.
   - Often misused for client-server auth; better suited for **server-to-server** auth.
   - Using refresh tokens makes it **stateful/hybrid**.
   

6. **Recommendation**  
   - Use **stateful auth** (session-based) for control and security.
   - Use **stateless** only if you trust all users and scalability is critical.



### **Key Takeaways:**
- **Stateful**: Server stores session data â†’ more control, can revoke access.
- **Stateless**: No server storage â†’ less control, but more scalable.
- **JWT**: Often misused; refresh tokens make it stateful anyway.
- **Hybrid approach**: Common in practice (JWT + refresh token).

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 2) Encryption & Hashing

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>


#### Terminology in Encryption/Decryption

| Term               | Description                                                               |
| ------------------ | ------------------------------------------------------------------------- |
| **Plaintext**      | The original readable message or data.                                    |
| **Ciphertext**     | The encrypted, unreadable version of the plaintext.                       |
| **Encryption**     | The process of converting plaintext into ciphertext using a key.          |
| **Decryption**     | The process of converting ciphertext back to plaintext using a key.       |
| **Key**            | A secret value used in encryption and decryption.                         |
| **Symmetric Key**  | The same key is used for both encryption and decryption.                  |
| **Asymmetric Key** | A key pair: public key (for encryption) and private key (for decryption). |


### 2. **Hashing (Irreversible)**

Hashing is the process of converting data into a fixed-size bits, which typically represents a digest of that data. It is **one-way**, meaning it cannot be reversed.

#### Common Algorithms:

- SHA-256 (Secure Hash Algorithm)
- MD5 (Message Digest Algorithm) (Obsolete)
- SHA-1 (Obsolete)

#### âœï¸ Terminology in Hashing

| Term              | Description                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| **Message**       | The original input data (e.g., a password, file, or string).           |
| **Hash / Digest** | The fixed-length output generated by the hashing algorithm.            |
| **Hash Function** | The algorithm that maps data of arbitrary size to a fixed-size output. |
| **Collision**     | When two different inputs produce the same hash (undesirable).         |
| **Salt**          | Random data added to input to prevent hash-based attacks.              |

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">

# 3) createHash() in Node.js (Crypto)

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

</br>

**âœ” What is createHash()?**
- `createHash()` is a method from Node.js crypto module
- Used to generate HASH of data
- Hash = one-way encrypted value (cannot be reversed)


**âœ” Import crypto module**
- `createHash()` -> Creates hash object 
- `update()` -> Adds data to hash 
- `digest()` -> Final output 

```js
const crypto = require("crypto");
```

```js
crypto.createHash(algorithm)
```

**âœ” Basic Example**

```js
const crypto = require("crypto");

const hash = crypto
  .createHash("sha256")
  .update("password123")
  .digest("hex");

console.log(hash);
```


**âœ” When to Use createHash()?**
- File checksum
- Tokens
- API signature
- Non-password hashing


**âœ” Interview Line **

"createHash() is used to generate a one-way cryptographic hash of data using algorithms like SHA-256."


</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">



# 4) How Hashing is Used in Git 

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

## 1. Git's Hash Mechanism
- **Algorithm**: Git uses **SHA-1** for hashing (historically)
- **Purpose**: Identifies commits, files, and objects uniquely
- **Output Format**: 40-character hexadecimal string

## 2. Git Object Hashing Process

### What Git Actually Hashes:
Git doesn't hash raw file content directly. Instead, it creates a **Git object** by prepending metadata:

```
Format: "blob <content_length>\0<file_content>"
```

Example for a file containing "hello world":
```javascript
// Git creates this structure:
const gitObject = "blob 11\0hello world";
// Then hashes this entire string with SHA-1
```

### Node.js Code to Recreate Git's Hash:
```javascript
import { readFile } from 'fs/promises';
import crypto from 'crypto';

async function calculateGitHash(filename) {
    // Read file content
    const fileData = await readFile(filename);
    
    // Create Git object format
    const contentLength = fileData.length;
    const gitObject = `blob ${contentLength}\0${fileData}`;
    
    // Calculate SHA-1 hash
    const hash = crypto.createHash('sha1');
    hash.update(gitObject);
    const gitHash = hash.digest('hex');
    
    return gitHash;
}
```

## 3. Git's Storage Structure

### How Git Stores Hashed Objects:
1. **First 2 characters** â†’ Folder name
2. **Remaining 38 characters** â†’ File name inside folder

Example: Hash `5e1c309e...`
- Folder: `.git/objects/5e/`
- File: `1c309e...` (compressed content)

### Git Object Types:
1. **Blob**: File content
2. **Tree**: Directory structure
3. **Commit**: Commit metadata
4. **Tag**: Tag references


### Key Takeaways:
1. Git uses **SHA-1** for object identification
2. Hashes are calculated on **structured objects**, not raw files
3. **Avalanche effect** ensures even minor changes produce different hashes

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 5) Signing Cookies in Node.js

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

### Why Sign Cookies?
- To prevent users from modifying sensitive data in cookies (such as expiration time, user information, etc.)
- Even if cookies are Base64 encoded, users can still decode and modify the content
- Signing allows verification of whether cookie data has been altered

## Implementation Steps for Signing

### 1. Create a Signing Function
```javascript
// Import crypto module
import crypto from 'crypto';

// Define secret key (should use environment variables in real projects)
const SECRET_KEY = 'pro-coder-storage-app';

// Create signature
const signature = crypto
  .createHash('sha256')  // Use SHA-256 algorithm
  .update(payload)       // Add cookie data
  .update(SECRET_KEY)    // Add secret key
  .digest('base64url');  // Output in base64url format
```

### 2. Send Signed Cookies
- Convert raw data to Base64 format
- Generate signature for the data
- Connect data and signature using a separator (like a dot `.`)
- Send format: `base64data.signature`

### 3. Verify Signatures
```javascript
// Receive cookie and split it
const [payloadBase64, oldSignature] = token.split('.');

// Recalculate signature
const newSignature = crypto
  .createHash('sha256')
  .update(payload)      // Use received data
  .update(SECRET_KEY)   // Use the same secret key
  .digest('base64url');

// Compare signatures
if (newSignature !== oldSignature) {
  // Signature invalid, cookie tampered with
  res.clearCookie('token');
  return res.status(401).send('Not logged in');
}
```


###  Signature Algorithm Choice
- Use SHA-256 hash algorithm
- Output format uses base64url (URL-compatible, no padding characters)


## Connection to JSON Web Tokens (JWT)
- JWT uses the same fundamental principle
- JWT has three parts separated by two dots: `header.payload.signature`
- Understanding cookie signing helps understand JWT principles
- jwt signature as follow:

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret_key
)
```


</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">



# 6) Cookie Parser & Signed Cookies (Node.js / Express)

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

**âœ” What is Cookie Parser?**
- Express middleware for handling cookies
- Automatically parses cookies from request headers
- Makes cookies available as JS objects

**âœ” Problem Without Cookie Parser**
- Manual parsing of Cookie header
- String splitting & decoding
- No built-in signing / verification
- Error-prone & messy

**âœ” Installation**
`npm install cookie-parser`

**âœ” Basic Setup**
`app.use(cookieParser())`
- Parsed cookies â†’ req.cookies

**âœ” 1ï¸âƒ£ Setting Normal Cookie**
`res.cookie("username", "john", { httpOnly: true })`

**âœ” Reading Normal Cookie**
`req.cookies.username`

**âœ” 2ï¸âƒ£ What is Signed Cookie?**
- Cookie with tamper-detection
- Uses secret key + hashing
- NOT encryption (data is readable)

**âœ” Setup for Signed Cookies**
app.use(cookieParser("SECRET_KEY"))

**âœ” Sending Signed Cookie**
res.cookie("token", "data", { signed: true })

âœ” Reading Signed Cookie
req.signedCookies.token
- Valid â†’ value available
- Tampered â†’ false / undefined

**âœ” Behind the Scenes**
- Cookie stored as: `s:value.signature`
- Server recalculates signature
- If mismatch â†’ cookie rejected

**âœ” Security Benefit**
- Detects cookie modification
- Prevents privilege escalation
- Protects userId, roles, session data

**âœ” Important Rules âš ï¸**
- Signed â‰  Encrypted
- User can SEE data
- User cannot MODIFY data silently

**âœ” Where to Store Secret?**
- Environment variables
`process.env.COOKIE_SECRET`

**âœ” When to Use Signed Cookies?**
- User sessions
- Auth tokens
- Role / permission data

**âœ” Complete Implemented example**

```js
const express = require('express');
const cookieParser = require('cookie-parser');
const app = express();
app.use(cookieParser('test-secret'));

// Set a signed cookie
app.get('/set', (req, res) => {
  res.cookie('myCookie', 'secretData', { signed: true });
  res.send('Cookie set! Try visiting /get');
});

// Get the cookie
app.get('/get', (req, res) => {
  const normal = req.cookies.myCookie;
  const signed = req.signedCookies.myCookie;
  
  res.send(`
    Normal cookie: ${normal}<br>
    Signed cookie: ${signed}<br>
    Try modifying the cookie in browser and refresh!
  `);
});

app.listen(3000);
```



**âœ” Interview Line**

"cookie-parser simplifies cookie handling in Express and signed cookies add tamper detection using a secret key."

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">




# 7) What are Rainbow Tables?


<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>


**âœ” What are Rainbow Tables?**
- Precomputed tables of password â†’ hash mappings
- Used to crack hashed passwords quickly

âœ” Simple Definition
Rainbow Table â†’ already stored hashes used to guess original passwords

âœ” Protection Against Rainbow Tables ğŸ”
1) Salting (MOST IMPORTANT)
   salt + password â†’ hash
   - Same password â‰  same hash

2) Slow Hashing Algorithms
   - bcrypt
   - pbkdf2
   - scrypt
   - argon2

âœ” NOT Safe for Passwords âŒ
- md5
- sha1
- sha256 (without salt)


</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 8) Side Effect Import i ES6

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>


âœ” What is a KDF?
- Cryptographic algorithm to derive strong keys from passwords
- Makes weak passwords secure
- Designed to be slow & expensive for attackers


âœ” How KDF Works
Password + Salt
â†’ Hash
â†’ Hash again
â†’ Repeat (100,000+ times)
â†’ Final secure hash

âœ” 3 Magic Ingredients ğŸ”¥
1) Salt
   - Random per user
   - Same password â‰  same hash
   - Stops rainbow tables

2) Iterations
   - Number of hash rounds
   - Slows brute-force attacks
   - Recommended: 100kâ€“300k+

3) Key Length
   - Output size
   - Recommended: 32 bytes

âœ” PBKDF2 (Node.js Built-in KDF)
- Available in crypto module
- Uses HMAC internally
- Slow by design (good)

Example:
`crypto.pbkdf2(password, salt, iterations, keyLen, algo)`

âœ” Password Storage Format
- Store hash + salt together
- Example: hash.salt (base64url)

âœ” Password Verification Flow
1) Split stored hash & salt
2) Recalculate hash with entered password
3) Compare hashes
4) Match â†’ login success

âœ” Comparison (IMPORTANT)
- sha256 â†’ fast, unsafe
- HMAC â†’ better, still fast
- PBKDF2 â†’ slow, secure
- bcrypt â†’ slower, easier
- Argon2 â†’ most secure (modern)


âœ” Interview Line 
"A Key Derivation Function securely hashes passwords using salt and multiple iterations to resist brute-force and rainbow table attacks."

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 9) What is bcrypt?

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

</br>

- Password hashing algorithm
- Built specifically for storing passwords securely
- Uses salt + slow hashing (by design)



âœ” bcrypt Internals
- Based on Blowfish cipher
- Adds random salt automatically
- Hashing cost controlled by "salt rounds"

âœ” Salt Rounds (Cost Factor)
- Determines how slow hashing is
- Each increase doubles the work

Example:

```
10 rounds â†’ ok
12 rounds â†’ recommended
14+ â†’ very slow
```

âœ” How bcrypt Hash Looks
`$2b$12$randomSaltAndHashHere`

Meaning:
`$2b$` â†’ bcrypt version
`12`   â†’ salt rounds
`rest` â†’ salt + hash

âœ” Hashing Password (Node.js)
`const bcrypt = require('bcrypt');`

`const hash = await bcrypt.hash(password, 12);`

âœ” Verifying Password
`const isMatch = await bcrypt.compare(password, hash);`

âœ” IMPORTANT
- Never compare hashes manually
- Always use `bcrypt.compare()`


âœ” bcrypt vs sha256
- sha256 â†’ fast âŒ
- bcrypt â†’ slow âœ… (secure)



âœ” Interview Line 
"bcrypt is a password hashing algorithm that uses salting and adaptive cost to protect against brute-force and rainbow table attacks."

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">



# 10) Why Not to Use JWT for Login 

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>

## âŒ Why You Should Not Use JWTs for Login Sessions

JSON Web Tokens (JWTs) are often marketed as a modern solution for authentication. While they are useful in some contexts (like stateless service-to-service communication), **they are not ideal for client-server login authentication** â€” especially when used in place of traditional session management.

---

## ğŸš« Core Problems with JWT-Based Login Sessions

### 1. **Inability to Revoke Tokens Easily**
JWTs are **stateless** and **self-contained**, meaning:
- Once a token is issued, you **cannot invalidate it** unless you maintain a separate revocation list.
- This defeats the whole point of statelessness.

### 2. **Token Theft = Full Access**
If a JWT is stolen (via XSS, network leak, etc.):
- It gives the attacker **full access until it expires**
- No way to destroy it unless it expires or you manually track it in a DB/Redis (which reintroduces state)

### 3. **No Rotation or One-Time Use**
- JWTs do not have a built-in rotation system.
- Refresh tokens can mitigate this, but thatâ€™s extra complexity and doesn't solve the root problem of statelessness.

### 4. **Token Bloat**
- JWTs often contain embedded user data.
- These large tokens are sent **on every request**, bloating headers and impacting performance.

### 5. **Not Built for User Sessions**
JWTs were designed to **convey claims between parties**, not to **manage authentication sessions**.
- They are ideal for **federated identity** (e.g., OAuth/OpenID Connect)
- Not for managing a userâ€™s "logged-in state" on your app

---

## âœ… When Should You Use JWTs?

Use JWTs when:
- You need **stateless** authentication across microservices
- You're building **federated identity systems** (e.g., Google/Facebook login)

---

## âœ… Better Alternative: Server-Side Sessions

Use traditional **session IDs** stored in cookies:
- Easily invalidated (just destroy the session in DB)
- No sensitive user data stored on client
- Less risk of misuse
- Works beautifully with `HttpOnly` and `Secure` flags on cookies

---

## ğŸ”— References & Further Reading

1. ğŸ“˜ [Don't Use JWTs for Sessions â€” Ian London](https://ianlondon.github.io/posts/dont-use-jwts-for-sessions/)
2. ğŸ”§ [Redis: JWTs Are Not Safe](https://redis.io/resources/json-web-tokens-jwts-are-not-safe/)
3. ğŸ§  [GitHub Gist â€” JWTs as Session Tokens](https://gist.github.com/samsch/0d1f3d3b4745d778f78b230cf6061452)
4. ğŸ¥ [YouTube â€” Why You Shouldnâ€™t Use JWTs for Sessions (Ben Awad)](https://www.youtube.com/watch?v=pYeekwv3vC4)

---

## âš–ï¸ Summary

| Use Case                        | Should You Use JWT? |
|----------------------------------|----------------------|
| Login/auth sessions              | âŒ No               |
| Stateless service-to-service auth| âœ… Yes              |
| OAuth/OpenID identity tokens     | âœ… Yes              |
| Client-side session management   | âŒ No               |

---

## ğŸ§  Final Thought

JWTs are a powerful tool â€” but **only when used in the right context**.  
For login sessions, traditional **cookie-based sessions with server-side storage** remain **more secure, simpler to manage, and easier to revoke.**




</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">





# 10) Sending Emails Using Node.js (Nodemailer)

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>
## âœ… What is Nodemailer?

* **Nodemailer** is a **Node.js library** used to send emails
  * Email verification
  * OTP
  * Password reset
  * Notifications
  * Order confirmations


## âœ… Installation

```bash
npm install nodemailer
```

## âœ… Core Email Flow

```
Node.js App
   â†“
Nodemailer
   â†“
SMTP Server (Gmail / Outlook / Custom)
   â†“
User Inbox
```

## âœ… Basic Setup (Gmail Example)

```js
const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
  host: "smtp.ethereal.email",
  port: 587,
  secure: false, // Use true for port 465, false for port 587
  auth: {
    user: "maddison53@ethereal.email",
    pass: "jn7jnAPss4f63QBp6D",
  },
});
```

### ğŸ“Œ Important Notes

* âŒ Do NOT use Gmail normal password
* âœ… Enable **2-Step Verification**
* âœ… Generate **App Password**
* Store credentials in `.env`



## âœ… Sending a Simple Email

```js
// Send an email using async/await
(async () => {
  const info = await transporter.sendMail({
    from: '"firstName lastName" <your-email@xyz.com>',
    to: "bar@example.com, baz@example.com",
    subject: "Hello âœ”",
    text: "Hello world?", // Plain-text version of the message
    html: "<b>Hello world?</b>", // HTML version of the message
  });

  console.log("Message sent:", info.messageId);
})();
```


## âœ… Sending HTML Email

```js
const mailOptions = {
  from: "your_email@gmail.com",
  to: "user@gmail.com",
  subject: "Verify Your Email",
  html: `
    <h2>Email Verification</h2>
    <p>Click the button below</p>
    <a href="https://example.com/verify">Verify</a>
  `
};
```

---

## âœ… Async / Await Version (Recommended)

```js
await transporter.sendMail({
  from: process.env.EMAIL,
  to: user.email,
  subject: "OTP Verification",
  html: `<h3>Your OTP is ${otp}</h3>`
});
```

---

## âœ… Common Email Types in MERN Apps

| Use Case        | Email Content          |
| --------------- | ---------------------- |
| Signup          | Verification link      |
| Login           | OTP                    |
| Forgot Password | Reset link             |
| Orders          | Invoice / confirmation |
| Admin           | Alerts                 |

---

## âœ… Environment Variables (.env)

```env
EMAIL=your_email@gmail.com
EMAIL_PASS=your_app_password
```

```js
require("dotenv").config();
```

---

## âœ… Error Handling Best Practices

* Wrap `sendMail()` in `try/catch`
* Handle:

  * Invalid email
  * SMTP failure
  * Network issues
* Never expose error details to users

---

## âœ… Security Best Practices ğŸ”

* Never hardcode email/password
* Always use `.env`
* Rate-limit OTP emails
* Add expiry time for OTP
* Use HTTPS links only

---

## âœ… Interview One-Liner â­

> Nodemailer is a Node.js library used to send emails through SMTP servers for features like verification, OTP, and notifications.

---

## âœ… Summary (Quick Revision)

* Nodemailer = email sender for Node.js
* Uses SMTP
* Gmail needs App Password
* Supports text + HTML
* Used for OTP, reset, verification
* Secure with env variables


</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 11) OTP Email System (User Register) Using Nodemailer + Separate OTP Model (TTL Based) 

<details>
  <summary>ğŸ‘‰ğŸ¼ READ IN DETAILS:</summary>


## ğŸ” Overall Flow (UNCHANGED)

```
User registers
   â†“
Create User (unverified)
   â†“
Generate OTP
   â†“
Save OTP in OTP collection (TTL = 10 min)
   â†“
Send OTP via email
   â†“
User submits OTP
   â†“
Verify OTP
   â†“
Mark user as verified
```

---

## ğŸ“¦ Step 1: Install Packages

```bash
npm install nodemailer dotenv mongoose
```

---

## ğŸ” Step 2: Nodemailer Setup (Same as Before)

### `.env`

```env
EMAIL=yourgmail@gmail.com
EMAIL_PASS=your_gmail_app_password
```

---

### `utils/sendEmail.js`

```js
const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL,
    pass: process.env.EMAIL_PASS
  }
});

const sendEmail = async ({ to, subject, html }) => {
  await transporter.sendMail({
    from: `"My App" <${process.env.EMAIL}>`,
    to,
    subject,
    html
  });
};

module.exports = sendEmail;
```

---

## ğŸ§  Step 3: OTP Generator (Same)

### `utils/generateOtp.js`

```js
const generateOtp = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

module.exports = generateOtp;
```

---

## ğŸ‘¤ Step 4: User Model (OTP REMOVED)

### `models/User.js`

```js
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema({
  name: String,
  email: {
    type: String,
    unique: true
  },
  password: String,

  isVerified: {
    type: Boolean,
    default: false
  }
});

module.exports = mongoose.model("User", userSchema);
```

---

## ğŸ”‘ Step 5: OTP Model (NEW â€“ IMPORTANT)

### `models/Otp.js`

```js
const mongoose = require("mongoose");

const otpSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true
  },

  otp: {
    type: String,
    required: true
  },

  createdAt: {
    type: Date,
    default: Date.now,
    expires: 600   // â±ï¸ Auto-delete after 10 minutes
  }
});

module.exports = mongoose.model("Otp", otpSchema);
```

### ğŸ“Œ Why this is powerful

* MongoDB **automatically deletes OTP**
* No cron job needed
* Clean & secure
* Industry standard

---

## ğŸ“ Step 6: Register API (Create User + Send OTP)

### `routes/auth.js`

```js
const express = require("express");
const router = express.Router();

const User = require("../models/User");
const Otp = require("../models/Otp");
const sendEmail = require("../utils/sendEmail");
const generateOtp = require("../utils/generateOtp");

router.post("/register", async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // 1ï¸âƒ£ Check existing user
    const exists = await User.findOne({ email });
    if (exists) {
      return res.status(400).json({ message: "Email already registered" });
    }

    // 2ï¸âƒ£ Create user (unverified)
    const user = await User.create({
      name,
      email,
      password // hash in real apps
    });

    // 3ï¸âƒ£ Generate OTP
    const otp = generateOtp();

    // 4ï¸âƒ£ Save OTP in OTP collection
    await Otp.create({
      userId: user._id,
      otp
    });

    // 5ï¸âƒ£ Send OTP Email
    await sendEmail({
      to: email,
      subject: "Verify your email (OTP)",
      html: `
        <h2>Email Verification</h2>
        <p>Your OTP is:</p>
        <h1>${otp}</h1>
        <p>Valid for 10 minutes</p>
      `
    });

    res.status(201).json({
      message: "OTP sent to email",
      userId: user._id
    });

  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

module.exports = router;
```

---

## âœ… Step 7: Verify OTP API (Using OTP Model)

```js
router.post("/verify-otp", async (req, res) => {
  try {
    const { email, otp } = req.body;

    // 1ï¸âƒ£ Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // 2ï¸âƒ£ Find OTP record
    const otpRecord = await Otp.findOne({
      userId: user._id,
      otp
    });

    if (!otpRecord) {
      return res.status(400).json({ message: "Invalid or expired OTP" });
    }

    // 3ï¸âƒ£ Verify user
    user.isVerified = true;
    await user.save();

    // 4ï¸âƒ£ Delete OTP manually (optional, TTL will also handle)
    await Otp.deleteMany({ userId: user._id });

    res.json({ message: "Email verified successfully" });

  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});
```

---

## ğŸ” Step 8: Block Login Until Verified

```js
if (!user.isVerified) {
  return res.status(403).json({ message: "Please verify your email" });
}
```



## ğŸ§  Interview One-Liner

> We store OTPs in a separate collection with a TTL index so MongoDB automatically expires them, ensuring security, scalability, and clean user documents.
</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">