# 1) Stateful vs Serverless
<details>
  <summary>üëâüèº READ IN DETAILS:</summary>

1. **Definition of State in Authentication**  
   - **State** = data or information.
   - **Stateful** = server changes state (stores/removes data) when user logs in/out.
   - **Stateless** = server does **not** change any state; only provides a token (e.g., JWT).

2. **Gym Analogy**  
   - **Stateless Gym**: Member gets an ID card with expiry date. No internal record is kept. Can‚Äôt revoke access before expiry.
   - **Stateful Gym**: Member gets an ID, but gym keeps a register. Can revoke membership if member misbehaves.

3. **Drawbacks of Stateless Auth**  
   - No control over active sessions.
   - Cannot log out users before token expiry.
   - Cannot block malicious users immediately.
   - Stolen tokens remain valid until expiry.

4. **Drawbacks of Stateful Auth**  
   - More server load (storing sessions).
   - Slightly slower (needs to check session DB).

5. **JWT (JSON Web Token) Discussion**  
   - JWT is **stateless by design**.
   - Often misused for client-server auth; better suited for **server-to-server** auth.
   - Using refresh tokens makes it **stateful/hybrid**.
   

6. **Recommendation**  
   - Use **stateful auth** (session-based) for control and security.
   - Use **stateless** only if you trust all users and scalability is critical.



### **Key Takeaways:**
- **Stateful**: Server stores session data ‚Üí more control, can revoke access.
- **Stateless**: No server storage ‚Üí less control, but more scalable.
- **JWT**: Often misused; refresh tokens make it stateful anyway.
- **Hybrid approach**: Common in practice (JWT + refresh token).

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 2) Encryption & Hashing

<details>
  <summary>üëâüèº READ IN DETAILS:</summary>


#### Terminology in Encryption/Decryption

| Term               | Description                                                               |
| ------------------ | ------------------------------------------------------------------------- |
| **Plaintext**      | The original readable message or data.                                    |
| **Ciphertext**     | The encrypted, unreadable version of the plaintext.                       |
| **Encryption**     | The process of converting plaintext into ciphertext using a key.          |
| **Decryption**     | The process of converting ciphertext back to plaintext using a key.       |
| **Key**            | A secret value used in encryption and decryption.                         |
| **Symmetric Key**  | The same key is used for both encryption and decryption.                  |
| **Asymmetric Key** | A key pair: public key (for encryption) and private key (for decryption). |


### 2. **Hashing (Irreversible)**

Hashing is the process of converting data into a fixed-size bits, which typically represents a digest of that data. It is **one-way**, meaning it cannot be reversed.

#### Common Algorithms:

- SHA-256 (Secure Hash Algorithm)
- MD5 (Message Digest Algorithm) (Obsolete)
- SHA-1 (Obsolete)

#### ‚úçÔ∏è Terminology in Hashing

| Term              | Description                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| **Message**       | The original input data (e.g., a password, file, or string).           |
| **Hash / Digest** | The fixed-length output generated by the hashing algorithm.            |
| **Hash Function** | The algorithm that maps data of arbitrary size to a fixed-size output. |
| **Collision**     | When two different inputs produce the same hash (undesirable).         |
| **Salt**          | Random data added to input to prevent hash-based attacks.              |

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">

# 3) createHash() in Node.js (Crypto)

<details>
  <summary>üëâüèº READ IN DETAILS:</summary>

</br>

**‚úî What is createHash()?**
- `createHash()` is a method from Node.js crypto module
- Used to generate HASH of data
- Hash = one-way encrypted value (cannot be reversed)


**‚úî Import crypto module**
- `createHash()` -> Creates hash object 
- `update()` -> Adds data to hash 
- `digest()` -> Final output 

```js
const crypto = require("crypto");
```

```js
crypto.createHash(algorithm)
```

**‚úî Basic Example**

```js
const crypto = require("crypto");

const hash = crypto
  .createHash("sha256")
  .update("password123")
  .digest("hex");

console.log(hash);
```


**‚úî When to Use createHash()?**
- File checksum
- Tokens
- API signature
- Non-password hashing


**‚úî Interview Line **

"createHash() is used to generate a one-way cryptographic hash of data using algorithms like SHA-256."


</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">



# 4) How Hashing is Used in Git 

<details>
  <summary>üëâüèº READ IN DETAILS:</summary>

## 1. Git's Hash Mechanism
- **Algorithm**: Git uses **SHA-1** for hashing (historically)
- **Purpose**: Identifies commits, files, and objects uniquely
- **Output Format**: 40-character hexadecimal string

## 2. Git Object Hashing Process

### What Git Actually Hashes:
Git doesn't hash raw file content directly. Instead, it creates a **Git object** by prepending metadata:

```
Format: "blob <content_length>\0<file_content>"
```

Example for a file containing "hello world":
```javascript
// Git creates this structure:
const gitObject = "blob 11\0hello world";
// Then hashes this entire string with SHA-1
```

### Node.js Code to Recreate Git's Hash:
```javascript
import { readFile } from 'fs/promises';
import crypto from 'crypto';

async function calculateGitHash(filename) {
    // Read file content
    const fileData = await readFile(filename);
    
    // Create Git object format
    const contentLength = fileData.length;
    const gitObject = `blob ${contentLength}\0${fileData}`;
    
    // Calculate SHA-1 hash
    const hash = crypto.createHash('sha1');
    hash.update(gitObject);
    const gitHash = hash.digest('hex');
    
    return gitHash;
}
```

## 3. Git's Storage Structure

### How Git Stores Hashed Objects:
1. **First 2 characters** ‚Üí Folder name
2. **Remaining 38 characters** ‚Üí File name inside folder

Example: Hash `5e1c309e...`
- Folder: `.git/objects/5e/`
- File: `1c309e...` (compressed content)

### Git Object Types:
1. **Blob**: File content
2. **Tree**: Directory structure
3. **Commit**: Commit metadata
4. **Tag**: Tag references


### Key Takeaways:
1. Git uses **SHA-1** for object identification
2. Hashes are calculated on **structured objects**, not raw files
3. **Avalanche effect** ensures even minor changes produce different hashes

</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">


# 5) Signing Cookies in Node.js

<details>
  <summary>üëâüèº READ IN DETAILS:</summary>

### Why Sign Cookies?
- To prevent users from modifying sensitive data in cookies (such as expiration time, user information, etc.)
- Even if cookies are Base64 encoded, users can still decode and modify the content
- Signing allows verification of whether cookie data has been altered

## Implementation Steps for Signing

### 1. Create a Signing Function
```javascript
// Import crypto module
import crypto from 'crypto';

// Define secret key (should use environment variables in real projects)
const SECRET_KEY = 'pro-coder-storage-app';

// Create signature
const signature = crypto
  .createHash('sha256')  // Use SHA-256 algorithm
  .update(payload)       // Add cookie data
  .update(SECRET_KEY)    // Add secret key
  .digest('base64url');  // Output in base64url format
```

### 2. Send Signed Cookies
- Convert raw data to Base64 format
- Generate signature for the data
- Connect data and signature using a separator (like a dot `.`)
- Send format: `base64data.signature`

### 3. Verify Signatures
```javascript
// Receive cookie and split it
const [payloadBase64, oldSignature] = token.split('.');

// Recalculate signature
const newSignature = crypto
  .createHash('sha256')
  .update(payload)      // Use received data
  .update(SECRET_KEY)   // Use the same secret key
  .digest('base64url');

// Compare signatures
if (newSignature !== oldSignature) {
  // Signature invalid, cookie tampered with
  res.clearCookie('token');
  return res.status(401).send('Not logged in');
}
```


###  Signature Algorithm Choice
- Use SHA-256 hash algorithm
- Output format uses base64url (URL-compatible, no padding characters)


## Connection to JSON Web Tokens (JWT)
- JWT uses the same fundamental principle
- JWT has three parts separated by two dots: `header.payload.signature`
- Understanding cookie signing helps understand JWT principles
- jwt signature as follow:

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret_key
)
```

#
</details>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">